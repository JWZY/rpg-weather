<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RPG Weather Widget</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 512'><path fill='%23f4a261' d='M575.2 325.7c.2-1.9.8-3.7.8-5.6 0-35.3-28.7-64-64-64-12.6 0-24.2 3.8-34.1 10-17.6-38.8-56.5-66-101.9-66-61.8 0-112 50.1-112 112 0 3 .7 5.8.9 8.7-49.6 3.7-88.9 44.7-88.9 95.3 0 53 43 96 96 96h272c53 0 96-43 96-96 0-42.1-27.2-77.4-64.8-90.4zm-430.4-22.6c-43.7-43.7-43.7-114.7 0-158.3 43.7-43.7 114.7-43.7 158.4 0 9.7 9.7 16.9 20.9 22.3 32.7 9.8-3.7 20.1-6 30.7-7.5L386 81.1c4-11.9-7.3-23.1-19.2-19.2L279 91.2 237.5 8.4C232-2.8 216-2.8 210.4 8.4L169 91.2 81.1 61.9C69.3 58 58 69.3 61.9 81.1l29.3 87.8-82.8 41.5c-11.2 5.6-11.2 21.5 0 27.1l82.8 41.4-29.3 87.8c-4 11.9 7.3 23.1 19.2 19.2l76.1-25.3c6.1-12.4 14-23.7 23.6-33.5-13.1-5.4-25.4-13.4-36-24zm-4.8-79.2c0 40.8 29.3 74.8 67.9 82.3 8-4.7 16.3-8.8 25.2-11.7 5.4-44.3 31-82.5 67.4-105C287.3 160.4 258 140 224 140c-46.3 0-84 37.6-84 83.9z'/></svg>">
  <meta name="description" content="A tabletop RPG weather generator with 12 biomes, dynamic weather, and time of day. Perfect for D&D, Pathfinder, and other TTRPGs.">

  <!-- Open Graph / Social Media Preview -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="RPG Weather Widget">
  <meta property="og:description" content="A tabletop RPG weather generator with 12 biomes, dynamic weather, and time of day.">
  <meta property="og:image" content="https://jwzy.github.io/rpg-weather/preview.png">
  <meta property="og:url" content="https://jwzy.github.io/rpg-weather/">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="RPG Weather Widget">
  <meta name="twitter:description" content="A tabletop RPG weather generator with 12 biomes, dynamic weather, and time of day.">
  <meta name="twitter:image" content="https://jwzy.github.io/rpg-weather/preview.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <style>
    :root {
      /* Default (Forest) colors */
      --widget-bg: linear-gradient(145deg, #1a4d2e 0%, #0d2618 100%);
      --text-primary: #ffffff;
      --text-secondary: rgba(255, 255, 255, 0.7);
      --text-tertiary: rgba(255, 255, 255, 0.5);
      --accent: #4ade80;
      --particle-color: rgba(74, 222, 128, 0.6);
    }

    /* Biome color schemes */
    .biome-forest {
      --widget-bg: linear-gradient(145deg, #1a4d2e 0%, #0d2618 100%);
      --accent: #4ade80;
      --particle-color: rgba(74, 222, 128, 0.6);
    }

    .biome-desert {
      --widget-bg: linear-gradient(145deg, #c4a35a 0%, #8b6914 100%);
      --accent: #fbbf24;
      --particle-color: rgba(251, 191, 36, 0.7);
    }

    .biome-tundra {
      --widget-bg: linear-gradient(145deg, #64b5d9 0%, #2d5a6b 100%);
      --accent: #93c5fd;
      --particle-color: rgba(147, 197, 253, 0.8);
    }

    .biome-swamp {
      --widget-bg: linear-gradient(145deg, #4a5d23 0%, #2d3a14 100%);
      --accent: #84cc16;
      --particle-color: rgba(132, 204, 22, 0.5);
    }

    .biome-mountains {
      --widget-bg: linear-gradient(145deg, #64748b 0%, #334155 100%);
      --accent: #94a3b8;
      --particle-color: rgba(148, 163, 184, 0.7);
    }

    .biome-plains {
      --widget-bg: linear-gradient(145deg, #84a63c 0%, #4d6b1a 100%);
      --accent: #bef264;
      --particle-color: rgba(190, 242, 100, 0.6);
    }

    .biome-coast {
      --widget-bg: linear-gradient(145deg, #0891b2 0%, #164e63 100%);
      --accent: #22d3ee;
      --particle-color: rgba(34, 211, 238, 0.7);
    }

    .biome-jungle {
      --widget-bg: linear-gradient(145deg, #166534 0%, #052e16 100%);
      --accent: #22c55e;
      --particle-color: rgba(34, 197, 94, 0.6);
    }

    .biome-volcanic {
      --widget-bg: linear-gradient(145deg, #7f1d1d 0%, #1c0a0a 100%);
      --accent: #f97316;
      --particle-color: rgba(249, 115, 22, 0.7);
    }

    .biome-arctic {
      --widget-bg: linear-gradient(145deg, #e0f2fe 0%, #7dd3fc 100%);
      --accent: #38bdf8;
      --text-primary: #0c4a6e;
      --text-secondary: rgba(12, 74, 110, 0.7);
      --text-tertiary: rgba(12, 74, 110, 0.5);
      --particle-color: rgba(255, 255, 255, 0.9);
    }

    .biome-savanna {
      --widget-bg: linear-gradient(145deg, #d4a574 0%, #92631a 100%);
      --accent: #f59e0b;
      --particle-color: rgba(245, 158, 11, 0.6);
    }

    .biome-cavern {
      --widget-bg: linear-gradient(145deg, #4c1d95 0%, #1e1b4b 100%);
      --accent: #a78bfa;
      --particle-color: rgba(167, 139, 250, 0.5);
    }

    /* Time of day overlays - gradient-based, Disney/Pixar inspired */
    /* Morning: Golden dawn rising from bottom, lavender sky above (40% intensity) */
    .time-morning {
      --time-gradient: linear-gradient(
        to top,
        rgba(255, 140, 66, 0.42) 0%,
        rgba(255, 183, 130, 0.28) 35%,
        rgba(255, 220, 180, 0.14) 60%,
        rgba(147, 112, 219, 0.10) 100%
      );
      --time-intensity: 0.4;
    }

    /* Afternoon: Subtle warm overhead light, biome dominates (15% intensity) */
    .time-afternoon {
      --time-gradient: linear-gradient(
        to bottom,
        rgba(135, 206, 250, 0.05) 0%,
        rgba(255, 250, 235, 0.08) 40%,
        rgba(255, 223, 130, 0.10) 100%
      );
      --time-intensity: 0.15;
    }

    /* Evening: Dramatic purple-to-orange sunset (45% intensity) */
    .time-evening {
      --time-gradient: linear-gradient(
        to top,
        rgba(255, 130, 60, 0.38) 0%,
        rgba(210, 95, 85, 0.34) 25%,
        rgba(160, 75, 110, 0.42) 55%,
        rgba(90, 50, 120, 0.52) 80%,
        rgba(60, 30, 100, 0.55) 100%
      );
      --time-intensity: 0.45;
    }

    /* Night: Deep sapphire sky, darker at top (60% intensity) */
    .time-night {
      --time-gradient: linear-gradient(
        to top,
        rgba(35, 55, 90, 0.52) 0%,
        rgba(26, 42, 72, 0.62) 30%,
        rgba(18, 32, 58, 0.70) 60%,
        rgba(10, 22, 45, 0.76) 100%
      );
      --time-intensity: 0.6;
    }

    /* Cavern is always night (no daylight underground!) */
    .biome-cavern {
      --time-gradient: linear-gradient(
        to top,
        rgba(35, 55, 90, 0.52) 0%,
        rgba(26, 42, 72, 0.62) 30%,
        rgba(18, 32, 58, 0.70) 60%,
        rgba(10, 22, 45, 0.76) 100%
      );
      --time-intensity: 0.6;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 24px;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
      -webkit-font-smoothing: antialiased;
      padding: 24px;
    }

    /* iOS Medium Widget: 329x155pt, 20px radius */
    .widget {
      width: 329px;
      height: 155px;
      background: var(--widget-bg);
      border-radius: 20px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
    }

    /* Time overlay - gradient with per-time intensity */
    .widget::before {
      content: '';
      position: absolute;
      inset: 0;
      background: var(--time-gradient, transparent);
      opacity: var(--time-intensity, 1);
      pointer-events: none;
      z-index: 0;
      transition: background 0.6s ease, opacity 0.6s ease;
    }

    /* Weather particles container */
    .weather-particles {
      position: absolute;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.6s ease;
      z-index: 1;
    }

    .widget.loaded .weather-particles {
      opacity: 1;
    }

    /* Header row */
    .widget-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      position: relative;
      z-index: 2;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .widget-icon {
      width: 14px;
      height: 14px;
      color: var(--accent);
    }

    .widget-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .biome-badge {
      display: flex;
      align-items: center;
      gap: 4px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(8px);
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .biome-badge .biome-icon {
      width: 12px;
      height: 12px;
      opacity: 0.8;
    }

    /* Visual area */
    .visual-area {
      flex: 1;
      position: relative;
      z-index: 1;
    }

    /* Bottom row */
    .widget-bottom {
      display: flex;
      position: relative;
      z-index: 2;
    }

    .bottom-left {
      flex: 1;
      padding: 10px 14px;
    }

    .weather-name {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .weather-detail {
      font-size: 11px;
      color: var(--text-tertiary);
    }

    .bottom-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: center;
      padding: 10px 14px;
    }

    .temp-feel {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .wind-speed {
      font-size: 11px;
      color: var(--text-tertiary);
    }

    /* Time icon in header (SVG) */
    .time-icon {
      width: 14px;
      height: 14px;
      color: var(--accent);
    }

    /* Savanna needs white icon for visibility */
    .biome-savanna .time-icon {
      color: rgba(255, 255, 255, 0.85);
    }

    /* Loading skeleton */
    .skeleton {
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0.06) 0%,
        rgba(255, 255, 255, 0.12) 50%,
        rgba(255, 255, 255, 0.06) 100%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s ease-in-out infinite;
      border-radius: 4px;
    }

    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* Load animations */
    .widget.loaded .widget-header {
      animation: fadeSlideIn 0.3s ease-out 0ms both;
    }

    .widget.loaded .widget-bottom {
      animation: fadeSlideIn 0.3s ease-out 100ms both;
    }

    @keyframes fadeSlideIn {
      from {
        opacity: 0;
        transform: translateY(4px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Particle styles */
    .particle {
      position: absolute;
      pointer-events: none;
    }

    .particle.rain {
      width: 1px;
      height: 18px;
      background: linear-gradient(to bottom, transparent, rgba(240, 245, 255, 0.6));
      border-radius: 0.5px;
    }

    .particle.snow {
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 50%;
    }

    .particle.fog {
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      border-radius: 1px;
    }

    .particle.sand {
      width: 3px;
      height: 2px;
      background: rgba(210, 180, 140, 0.7);
      border-radius: 1px;
    }

    .particle.ash {
      width: 3px;
      height: 3px;
      background: rgba(128, 128, 128, 0.6);
      border-radius: 50%;
    }

    .particle.spark {
      width: 2px;
      height: 2px;
      background: rgba(255, 200, 100, 0.8);
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(255, 150, 50, 0.6);
    }

    /* God ray particle */
    .particle.ray {
      width: 8px;
      height: 120px;
      background: linear-gradient(
        to bottom,
        rgba(255, 250, 200, 0.5),
        rgba(255, 240, 150, 0.3) 30%,
        rgba(255, 240, 150, 0.1) 60%,
        transparent 85%
      );
      border-radius: 40% 40% 50% 50% / 5% 5% 50% 50%;
      filter: blur(3px);
      box-shadow: 0 0 15px rgba(255, 240, 150, 0.2);
    }

    .particle.sundust {
      border-radius: 50%;
      background: rgba(255, 255, 240, 0.6);
      box-shadow: 0 0 2px rgba(255, 250, 200, 0.4);
    }

    .particle.star {
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.8), 0 0 8px rgba(200, 220, 255, 0.4);
    }

    .particle.cloud {
      background: radial-gradient(ellipse at center,
        rgba(255, 255, 255, 0.15) 0%,
        rgba(255, 255, 255, 0.08) 40%,
        transparent 70%
      );
      border-radius: 50%;
      filter: blur(8px);
    }

    .particle.splash {
      width: 4px;
      height: 2px;
      background: rgba(240, 245, 255, 0.5);
      border-radius: 50%;
    }

    .particle.snowflake {
      background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.3) 70%, transparent 100%);
      border-radius: 50%;
      box-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
    }

    .particle.fogbank {
      background: linear-gradient(90deg,
        transparent,
        rgba(255, 255, 255, 0.15) 20%,
        rgba(255, 255, 255, 0.25) 50%,
        rgba(255, 255, 255, 0.15) 80%,
        transparent
      );
      border-radius: 50%;
      filter: blur(3px);
    }

    .particle.ember {
      background: radial-gradient(circle, rgba(255, 200, 50, 1) 0%, rgba(255, 100, 0, 0.8) 50%, transparent 100%);
      border-radius: 50%;
      box-shadow: 0 0 6px rgba(255, 150, 50, 0.8), 0 0 12px rgba(255, 100, 0, 0.4);
    }

    .particle.drip {
      width: 3px;
      height: 6px;
      background: linear-gradient(to bottom, transparent, rgba(100, 150, 200, 0.6));
      border-radius: 0 0 2px 2px;
    }

    /* Lightning flash */
    .lightning-flash {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.8);
      opacity: 0;
      pointer-events: none;
      z-index: 3;
    }

    .lightning-flash.active {
      animation: flash 0.15s ease-out;
    }

    @keyframes flash {
      0% { opacity: 0.8; }
      100% { opacity: 0; }
    }

    /* ============================================
       LIQUID GLASS CONTROL PANEL
       ============================================ */
    .control-panel {
      width: 329px;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 16px;
      padding: 16px;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .control-group {
      margin-bottom: 16px;
    }

    .control-group:last-child {
      margin-bottom: 0;
    }

    .control-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .control-label span {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-tertiary);
    }

    /* Select dropdown styling */
    .control-select {
      width: 100%;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='rgba(255,255,255,0.5)' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
    }

    .control-select:focus {
      outline: none;
      border-color: var(--accent);
    }

    .control-select option {
      background: #1a1a2e;
      color: white;
    }

    /* Time buttons grid */
    .time-grid {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .time-btn {
      flex: 1;
      min-width: 40px;
      padding: 6px 4px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: var(--text-tertiary);
      font-size: 9px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .time-btn svg {
      width: 14px;
      height: 14px;
    }

    .time-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      color: var(--text-primary);
    }

    .time-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #000;
    }

    /* Randomize button - small inline version */
    .randomize-btn {
      padding: 3px 8px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 9px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .randomize-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      color: var(--text-primary);
    }

    .randomize-btn:active {
      transform: scale(0.95);
    }

    /* Byline */
    .byline {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      text-align: center;
    }

    .byline a {
      color: rgba(255, 255, 255, 0.6);
      text-decoration: none;
      transition: color 0.15s ease;
    }

    .byline a:hover {
      color: rgba(255, 255, 255, 0.9);
    }

    /* Fullscreen mode */
    .fullscreen-container {
      position: fixed;
      inset: 0;
      background: #000;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      overflow: hidden;
    }

    .fullscreen-container.active {
      display: flex;
    }

    .fullscreen-container .widget {
      border-radius: 0;
      box-shadow: none;
      transform-origin: center center;
      cursor: pointer;
      /* Subtle blur for softer, more cinematic feel */
      filter: blur(0.5px);
    }

    /* Hide widget UI in fullscreen (we show separate overlay instead) */
    .fullscreen-container .widget-header,
    .fullscreen-container .widget-bottom {
      display: none !important;
    }

    /* Fullscreen UI overlay - separate from the blurred widget */
    .fullscreen-ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10001;
      padding: 24px 32px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .fullscreen-container.active.ui-visible .fullscreen-ui {
      opacity: 1;
    }

    .fullscreen-ui-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    .fullscreen-ui-bottom {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
    }

    .fullscreen-ui-time {
      display: flex;
      align-items: center;
      gap: 8px;
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      font-weight: 500;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
    }

    .fullscreen-ui-time svg {
      width: 18px;
      height: 18px;
      color: var(--accent);
    }

    /* Savanna needs white icon for visibility in fullscreen too */
    .biome-savanna .fullscreen-ui-time svg {
      color: rgba(255, 255, 255, 0.85);
    }

    .fullscreen-ui-biome {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      padding: 8px 14px;
      border-radius: 10px;
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      font-weight: 500;
    }

    .fullscreen-ui-biome svg {
      width: 16px;
      height: 16px;
    }

    .fullscreen-ui-weather {
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
    }

    .fullscreen-ui-weather-name {
      font-size: 20px;
      font-weight: 500;
      margin-bottom: 2px;
    }

    .fullscreen-ui-weather-detail {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.6);
    }

    .fullscreen-ui-conditions {
      text-align: right;
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
    }

    .fullscreen-ui-temp {
      font-size: 18px;
      font-weight: 500;
      margin-bottom: 2px;
    }

    .fullscreen-ui-wind {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.6);
    }

    /* Fullscreen API styles */
    .fullscreen-container:fullscreen {
      display: flex;
    }

    .fullscreen-container:-webkit-full-screen {
      display: flex;
    }

    /* Hint text for fullscreen - synced with UI visibility */
    .fullscreen-hint {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.5);
      font-size: 13px;
      pointer-events: none;
      opacity: 0;
      z-index: 10001;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      transition: opacity 0.3s ease;
    }

    .fullscreen-container.active.ui-visible .fullscreen-hint {
      opacity: 1;
    }

    /* Widget clickable cursor */
    .widget {
      cursor: pointer;
    }

    /* Zoom transition for entering fullscreen */
    .fullscreen-container .widget {
      transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                  border-radius 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                  filter 0.3s ease;
    }

    .fullscreen-container.zooming .widget {
      transition: none;
      filter: none;
    }
  </style>
</head>
<body>
  <!-- Fullscreen container (cloned widget goes here) -->
  <div class="fullscreen-container" id="fullscreenContainer">
    <!-- UI overlay (not blurred, fades out) -->
    <div class="fullscreen-ui" id="fullscreenUI">
      <div class="fullscreen-ui-top">
        <div class="fullscreen-ui-time">
          <svg id="fsTimeIcon" viewBox="0 0 24 24" fill="currentColor"></svg>
          <span id="fsTimeLabel">MORNING</span>
        </div>
        <div class="fullscreen-ui-biome">
          <svg id="fsBiomeIcon" viewBox="0 0 24 24" fill="currentColor"></svg>
          <span id="fsBiomeLabel">Forest</span>
        </div>
      </div>
      <div class="fullscreen-ui-bottom">
        <div class="fullscreen-ui-weather">
          <div class="fullscreen-ui-weather-name" id="fsWeatherName">Clear</div>
          <div class="fullscreen-ui-weather-detail" id="fsWeatherDetail">Calm conditions</div>
        </div>
        <div class="fullscreen-ui-conditions">
          <div class="fullscreen-ui-temp" id="fsTempFeel">Mild</div>
          <div class="fullscreen-ui-wind" id="fsWindSpeed">Calm</div>
        </div>
      </div>
    </div>
    <div class="fullscreen-hint">Tap anywhere to exit</div>
  </div>

  <div class="widget biome-forest time-morning" id="weatherWidget">
    <div class="weather-particles" id="particles"></div>
    <div class="lightning-flash" id="lightning"></div>

    <!-- Header row -->
    <div class="widget-header">
      <div class="header-left">
        <svg class="time-icon" id="timeIcon" viewBox="0 0 24 24"></svg>
        <span class="widget-title" id="timeLabel">MORNING</span>
      </div>
      <div class="biome-badge" id="biomeBadge">
        <svg class="biome-icon" id="biomeIcon" viewBox="0 0 24 24"></svg>
        <span id="biomeLabel">Forest</span>
      </div>
    </div>

    <!-- Visual area (particles render here) -->
    <div class="visual-area"></div>

    <!-- Bottom row -->
    <div class="widget-bottom">
      <div class="bottom-left">
        <div class="weather-name" id="weatherName">Partly Cloudy</div>
        <div class="weather-detail" id="weatherDetail">Mild breeze</div>
      </div>
      <div class="bottom-right">
        <div class="temp-feel" id="tempFeel">Pleasant</div>
        <div class="wind-speed" id="windSpeed">Light breeze</div>
      </div>
    </div>
  </div>

  <!-- Control Panel -->
  <div class="control-panel">
    <div class="control-group">
      <div class="control-label">
        <span>Time of Day</span>
      </div>
      <div class="time-grid" id="timeGrid">
        <button class="time-btn active" data-time="morning">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <circle cx="12" cy="12" r="4"/>
            <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/>
          </svg>
          Morning
        </button>
        <button class="time-btn" data-time="afternoon">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <circle cx="12" cy="12" r="5"/>
            <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
          </svg>
          Afternoon
        </button>
        <button class="time-btn" data-time="evening">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
          </svg>
          Evening
        </button>
        <button class="time-btn" data-time="night">
          <svg viewBox="0 0 24 24" fill="currentColor">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
            <circle cx="18" cy="5" r="1"/>
            <circle cx="15" cy="8" r="0.5"/>
          </svg>
          Night
        </button>
      </div>
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Biome</span>
      </div>
      <select class="control-select" id="biomeSelect">
        <option value="forest">Forest</option>
        <option value="desert">Desert</option>
        <option value="tundra">Tundra</option>
        <option value="swamp">Swamp</option>
        <option value="mountains">Mountains</option>
        <option value="plains">Plains</option>
        <option value="coast">Coast</option>
        <option value="jungle">Jungle</option>
        <option value="volcanic">Volcanic</option>
        <option value="arctic">Arctic</option>
        <option value="savanna">Savanna</option>
        <option value="cavern">Cavern</option>
      </select>
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Weather</span>
        <button class="randomize-btn" id="randomizeBtn">Random</button>
      </div>
      <select class="control-select" id="weatherSelect">
        <!-- Options populated dynamically based on biome -->
      </select>
    </div>

  </div>

  <div class="byline">by <a href="https://github.com/jwzy" target="_blank">Javan Wang</a></div>

  <script>
    // Biome-weather mapping
    const BIOME_WEATHER = {
      forest: ['clear', 'cloudy', 'rain', 'fog', 'storm'],
      desert: ['clear', 'windy', 'hot', 'sandstorm'],
      tundra: ['clear', 'cloudy', 'snow', 'blizzard'],
      swamp: ['cloudy', 'foggy', 'rain', 'humid'],
      mountains: ['clear', 'windy', 'snow', 'storm', 'fog'],
      plains: ['clear', 'cloudy', 'rain', 'windy', 'storm'],
      coast: ['clear', 'cloudy', 'rain', 'fog', 'storm'],
      jungle: ['humid', 'rain', 'downpour', 'misty'],
      volcanic: ['ash', 'smoke', 'hot', 'fiery'],
      arctic: ['blizzard', 'snow', 'clear', 'ice_storm'],
      savanna: ['clear', 'dry', 'windy', 'dust'],
      cavern: ['damp', 'dripping', 'humid']
    };

    // Weather display info
    const WEATHER_INFO = {
      clear: { name: 'Clear', detail: 'Calm conditions', particles: 'rays' },
      cloudy: { name: 'Cloudy', detail: 'Overcast skies', particles: 'clouds' },
      rain: { name: 'Rain', detail: 'Steady rainfall', particles: 'rain' },
      fog: { name: 'Fog', detail: 'Low visibility', particles: 'fog' },
      storm: { name: 'Storm', detail: 'Thunder and lightning', particles: 'storm' },
      windy: { name: 'Windy', detail: 'Strong gusts', particles: 'wind' },
      hot: { name: 'Hot', detail: 'Scorching heat', particles: 'heat' },
      sandstorm: { name: 'Sandstorm', detail: 'Blowing sand', particles: 'sand' },
      snow: { name: 'Snow', detail: 'Light snowfall', particles: 'snow' },
      blizzard: { name: 'Blizzard', detail: 'Heavy snow and wind', particles: 'blizzard' },
      foggy: { name: 'Foggy', detail: 'Dense fog', particles: 'fog' },
      humid: { name: 'Humid', detail: 'Thick moisture', particles: 'mist' },
      downpour: { name: 'Downpour', detail: 'Heavy rain', particles: 'downpour' },
      misty: { name: 'Misty', detail: 'Light mist', particles: 'mist' },
      ash: { name: 'Ash', detail: 'Falling ash', particles: 'ash' },
      smoke: { name: 'Smoke', detail: 'Thick smoke', particles: 'smoke' },
      fiery: { name: 'Fiery', detail: 'Sparks flying', particles: 'sparks' },
      ice_storm: { name: 'Ice Storm', detail: 'Freezing rain', particles: 'ice' },
      dry: { name: 'Dry', detail: 'Arid conditions', particles: 'none' },
      dust: { name: 'Dust', detail: 'Dusty winds', particles: 'dust' },
      dark: { name: 'Dark', detail: 'Pitch black', particles: 'none' },
      damp: { name: 'Damp', detail: 'Moisture dripping', particles: 'drip' },
      dripping: { name: 'Dripping', detail: 'Water dripping', particles: 'drip' }
    };

    // Time icons (SVG paths)
    const TIME_ICONS = {
      morning: '<circle cx="12" cy="12" r="4" fill="currentColor"/><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41" stroke="currentColor" stroke-width="2"/>',
      afternoon: '<circle cx="12" cy="12" r="5" fill="currentColor"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2"/>',
      evening: '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" fill="currentColor"/>',
      night: '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" fill="currentColor"/><circle cx="18" cy="5" r="1" fill="currentColor"/><circle cx="15" cy="8" r="0.5" fill="currentColor"/><circle cx="20" cy="9" r="0.5" fill="currentColor"/>'
    };

    // Biome icons (Font Awesome Pro SVG paths with viewBox)
    const BIOME_ICONS = {
      forest: { viewBox: '0 0 640 512', path: '<path d="M298.42 288h30.63c9.01 0 16.98-5 20.78-13.06 3.8-8.04 2.55-17.26-3.28-24.05L268.42 160h28.89c9.1 0 17.3-5.35 20.86-13.61 3.52-8.13 1.86-17.59-4.24-24.08L203.66 4.83c-6.03-6.45-17.28-6.45-23.32 0L70.06 122.31c-6.1 6.49-7.75 15.95-4.24 24.08C69.39 154.65 77.59 160 86.69 160h28.89l-78.14 90.91c-5.81 6.78-7.06 15.99-3.27 24.04C37.97 283 45.93 288 54.95 288h30.63L5.69 378.49c-6 6.79-7.36 16.09-3.56 24.26 3.75 8.05 12 13.25 21.01 13.25H160v24.45l-30.29 48.4c-5.32 10.64 2.42 23.16 14.31 23.16h95.96c11.89 0 19.63-12.52 14.31-23.16L224 440.45V416h136.87c9.01 0 17.26-5.2 21.01-13.25 3.8-8.17 2.44-17.47-3.56-24.26L298.42 288zm335.89 90.49L554.42 288h30.63c9.01 0 16.98-5 20.78-13.06 3.8-8.04 2.55-17.26-3.28-24.05L524.42 160h28.89c9.1 0 17.3-5.35 20.86-13.61 3.52-8.13 1.86-17.59-4.24-24.08L459.66 4.83c-6.03-6.45-17.28-6.45-23.32 0l-95.06 101.26c11.09 15.37 13.97 35.3 6.34 52.96-4 9.27-10.38 17.03-18.26 22.68l41.54 48.32c13.93 16.25 17.04 39.23 7.94 58.52-4.19 8.89-10.46 16.24-18.11 21.58l41.62 47.15c8.65 9.8 13.34 14.15 13.65 26.69v56.45l-30.29 48.4c-5.32 10.64 2.42 23.16 14.31 23.16h95.96c11.89 0 19.63-12.52 14.31-23.16L480 440.45V416h136.87c9.01 0 17.26-5.2 21.01-13.25 3.79-8.17 2.43-17.47-3.57-24.26z" fill="currentColor"/>' },
      desert: { viewBox: '0 0 512 512', path: '<path d="M464 224a48 48 0 0 0-48 48v64a16 16 0 0 1-16 16h-48V101.43c0-52-38.93-98.58-90.84-101.29A96 96 0 0 0 160 96v128h-48a16 16 0 0 1-16-16v-64a48 48 0 0 0-96 0v64a112 112 0 0 0 112 112h48v160a32 32 0 0 0 32 32h128a32 32 0 0 0 32-32v-32h48a112 112 0 0 0 112-112v-64a48 48 0 0 0-48-48zm-240-48a16 16 0 1 1 16-16 16 16 0 0 1-16 16zm64 224a16 16 0 1 1 16-16 16 16 0 0 1-16 16z" fill="currentColor"/>' },
      tundra: { viewBox: '0 0 640 512', path: '<path d="M608.1 256l27.9-16c3.8-2.2 5.1-7.1 2.9-10.9l-8-13.9c-2.2-3.8-7.1-5.1-10.9-2.9l-28 16.1V200c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v28.4l-28-16.1c-3.8-2.2-8.7-.9-10.9 2.9l-8 13.9c-2.2 3.8-.9 8.7 2.9 10.9l27.9 16-27.9 16c-3.8 2.2-5.1 7.1-2.9 10.9l8 13.9c2.2 3.8 7.1 5.1 10.9 2.9l28-16.1V312c0 4.4 3.6 8 8 8h16c4.4 0 8-3.6 8-8v-28.4l28 16.1c3.8 2.2 8.7.9 10.9-2.9l8-13.9c2.2-3.8.9-8.7-2.9-10.9l-27.9-16zM445.9 145.7l-15.5-26.8c-4.3-7.4-13.7-9.9-21.1-5.7l-33.8 19.5 7-26c2.2-8.2-2.7-16.7-10.9-18.9l-14.9-4c-8.2-2.2-16.7 2.7-18.9 10.9l-19 70.8-62.8 36.3v-77.5l53.7-53.7c6.2-6.2 6.2-16.4 0-22.6l-11.3-11.3c-6.2-6.2-16.4-6.2-22.6 0L256 56.4V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v40.4l-19.7-19.7c-6.2-6.2-16.4-6.2-22.6 0L138.3 48c-6.2 6.2-6.2 16.4 0 22.6l53.7 53.7v77.5l-62.8-36.2-19-70.8c-2.2-8.2-10.7-13.1-18.9-10.9l-14.9 4c-8.2 2.2-13.1 10.7-10.9 18.9l7 26-33.8-19.5c-7.4-4.3-16.8-1.7-21.1 5.7L2.1 145.7c-4.3 7.4-1.7 16.8 5.7 21.1l33.8 19.5-26 7c-8.3 2.2-13.2 10.7-11 19l4 14.9c2.2 8.2 10.7 13.1 18.9 10.9l70.8-19 63.8 36.9-63.8 36.9-70.8-19c-8.2-2.2-16.7 2.7-18.9 10.9l-4 14.9c-2.2 8.2 2.7 16.7 10.9 18.9l26 7-33.8 19.6c-7.4 4.3-9.9 13.7-5.7 21.1l15.5 26.8c4.3 7.4 13.7 9.9 21.1 5.7l33.8-19.5-7 26c-2.2 8.2 2.7 16.7 10.9 18.9l14.9 4c8.2 2.2 16.7-2.7 18.9-10.9l19-70.8 62.8-36.2v77.5l-53.7 53.7c-6.2 6.2-6.2 16.4 0 22.6l11.3 11.3c6.2 6.2 16.4 6.2 22.6 0l19.7-19.7V496c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-40.4l19.7 19.7c6.2 6.2 16.4 6.2 22.6 0l11.3-11.3c6.2-6.2 6.2-16.4 0-22.6L256 387.7v-77.5l62.8 36.2 19 70.8c2.2 8.2 10.7 13.1 18.9 10.9l14.9-4c8.2-2.2 13.1-10.7 10.9-18.9l-7-26 33.8 19.5c7.4 4.3 16.8 1.7 21.1-5.7l15.5-26.8c4.3-7.4 1.7-16.8-5.7-21.1l-33.8-19.5 26-7c8.2-2.2 13.1-10.7 10.9-18.9l-4-14.9c-2.2-8.2-10.7-13.1-18.9-10.9l-70.8 19-63.8-36.9 63.8-36.9 70.8 19c8.2 2.2 16.7-2.7 18.9-10.9l4-14.9c2.2-8.2-2.7-16.7-10.9-18.9l-26-7 33.8-19.5c7.5-4.3 10-13.8 5.7-21.2zm82-25.7c0 4.4 3.6 8 8 8h16c4.4 0 8-3.6 8-8V91.6l28 16.1c3.8 2.2 8.7.9 10.9-2.9l8-13.9c2.2-3.8.9-8.7-2.9-10.9L576 64l27.9-16c3.8-2.2 5.1-7.1 2.9-10.9l-8-13.9c-2.2-3.8-7.1-5.1-10.9-2.9l-28 16.1V8c0-4.4-3.6-8-8-8h-16c-4.4 0-8 3.6-8 8v28.4l-28-16.1c-3.8-2.2-8.7-.9-10.9 2.9l-8 13.9c-2.2 3.8-.9 8.7 2.9 10.9l27.9 16-27.9 16c-3.8 2.2-5.1 7.1-2.9 10.9l8 13.9c2.2 3.8 7.1 5.1 10.9 2.9l28-16.1V120z" fill="currentColor"/>' },
      swamp: { viewBox: '0 0 576 512', path: '<path d="M446.53 97.43C439.67 60.23 407.19 32 368 32c-39.23 0-71.72 28.29-78.54 65.54C126.75 112.96-.5 250.12 0 416.98.11 451.9 29.08 480 64 480h304c8.84 0 16-7.16 16-16 0-17.67-14.33-32-32-32h-79.49l35.8-48.33c24.14-36.23 10.35-88.28-33.71-106.6-23.89-9.93-51.55-4.65-72.24 10.88l-32.76 24.59c-7.06 5.31-17.09 3.91-22.41-3.19-5.3-7.08-3.88-17.11 3.19-22.41l34.78-26.09c36.84-27.66 88.28-27.62 125.13 0 10.87 8.15 45.87 39.06 40.8 93.21L469.62 480H560c8.84 0 16-7.16 16-16 0-17.67-14.33-32-32-32h-53.63l-98.52-104.68 154.44-86.65A58.16 58.16 0 0 0 576 189.94c0-21.4-11.72-40.95-30.48-51.23-40.56-22.22-98.99-41.28-98.99-41.28zM368 136c-13.26 0-24-10.75-24-24 0-13.26 10.74-24 24-24 13.25 0 24 10.74 24 24 0 13.25-10.75 24-24 24z" fill="currentColor"/>' },
      mountains: { viewBox: '0 0 640 512', path: '<path d="M635.73 406.91l-194.04-297.6c-11.57-17.75-39.8-17.75-51.37 0l-32.84 50.37 67.68 105.68c2.38 3.72 1.3 8.67-2.42 11.05l-13.46 8.62c-3.72 2.38-8.67 1.3-11.05-2.42l-59.9-93.54-70.81-110.55c-12.4-19.36-42.64-19.36-55.04 0L4.58 403.18C-7.99 422.81 6.81 448 30.92 448h580.22c22.5 0 36.32-23.09 24.59-41.09z" fill="currentColor"/>' },
      plains: { viewBox: '0 0 512 512', path: '<path d="M64 96H0c0 123.7 100.3 224 224 224v144c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V320C288 196.3 187.7 96 64 96zm384-64c-84.2 0-157.4 46.5-195.7 115.2 27.7 30.2 48.2 66.9 59 107.6C424 243.1 512 147.9 512 32h-64z" fill="currentColor"/>' },
      coast: { viewBox: '0 0 77 82', path: '<path d="M76.0352 20.0736C72.7891 14.1752 64.8122 13.2572 61.5042 21.0072C59.2737 26.2377 63.68 34.7372 56.5237 34.0932C48.3675 33.3589 52.8675 21.2022 52.6253 15.9722C52.4261 11.9839 50.8128 8.19883 48.0784 5.29223C45.344 2.38563 41.6643 0.546131 37.6994 0.104731C33.7306 -0.340579 29.7385 0.643792 26.4294 2.87423C16.1404 10.214 19.1716 22.5302 23.9567 27.8742C25.0231 29.0656 26.6715 30.4914 26.6247 32.5617C26.5817 34.5656 25.1091 38.6867 20.3435 36.1437C17.2341 34.4835 17.0544 31.6789 14.4607 29.5265C8.9998 24.9992 1.9017 27.4249 0.0507039 34.5617H0.0467976C-0.105542 35.1828 0.121017 35.839 0.624918 36.2336C1.12883 36.6321 1.81632 36.6985 2.38662 36.4055C4.41392 35.3625 5.82022 34.0696 7.35142 34.2571C8.83192 34.4368 9.26552 35.7454 11.2264 38.4876C13.1522 41.1829 14.5545 43.261 17.8983 44.2806C7.63632 47.7767 2.05432 48.1712 1.75332 56.7146C1.46816 60.1716 3.01892 63.5271 5.84312 65.5427C6.38218 65.8943 7.08142 65.8982 7.62432 65.5505C8.16729 65.2029 8.45635 64.5661 8.3626 63.9294C7.91338 61.0856 7.96026 57.7497 9.24151 56.3903C10.3509 55.2184 11.8743 54.6481 15.8977 53.9176C19.9602 53.1754 23.3625 53.3356 27.1437 48.7731C22.9523 57.1872 16.8237 60.7531 16.4837 67.1011C16.0189 75.73 23.7142 83.4721 30.5107 78.1751V78.1712C30.9287 77.8626 31.1005 77.3235 30.9443 76.8274C30.788 76.3313 30.331 75.9876 29.8115 75.9797C28.8623 75.9993 27.917 75.8352 27.0303 75.4993C22.4405 73.4485 23.5576 67.9798 28.0537 63.3433C32.5381 58.7183 36.8349 58.1089 38.0146 49.8203C39.7373 63.9293 34.2568 68.4723 41.3818 76.5313L41.3857 76.5235C43.6904 79.0704 46.8232 80.7149 50.2295 81.1719C50.9365 81.2773 51.6397 80.9258 51.9834 80.2969C52.3272 79.668 52.2412 78.8907 51.7686 78.3477C48.8038 75.1211 47.0186 70.9844 46.7061 66.6137C46.6709 62.0707 50.2647 58.9067 48.1709 49.0357C51.8623 51.8677 59.7409 59.6407 58.9599 64.2697H58.9638C58.495 66.7424 56.8583 68.84 54.5693 69.8947C54.2138 70.0548 53.9755 70.3947 53.9482 70.7853C53.9208 71.1759 54.1083 71.547 54.4365 71.7579C56.0693 72.9259 58.1045 73.3946 60.0849 73.0587C67.4208 71.4767 72.9949 54.3047 56.2763 43.0787C62.0107 45.3756 68.7763 41.4068 69.7533 32.7737C70.097 29.7229 67.1674 23.9846 69.8001 21.5937C70.7533 20.7305 72.5228 21.1133 74.2571 21.918H74.261C74.7845 22.168 75.4094 22.0547 75.8118 21.6328C76.2142 21.2148 76.3047 20.5853 76.0352 20.0736ZM31.8322 26.8002C30.883 26.8002 30.0314 26.2299 29.6681 25.3549C29.3048 24.4799 29.504 23.4682 30.1759 22.8002C30.8439 22.1284 31.8556 21.9292 32.7306 22.2924C33.6056 22.6557 34.1759 23.5072 34.1759 24.4565C34.1759 25.7495 33.1252 26.8002 31.8322 26.8002ZM43.7462 24.9135C42.797 24.9135 41.9454 24.3432 41.5821 23.4643C41.2188 22.5893 41.418 21.5815 42.0899 20.9135C42.7579 20.2417 43.7696 20.0425 44.6446 20.4018C45.5196 20.7651 46.0899 21.6206 46.0899 22.5698C46.0899 23.1909 45.8438 23.7886 45.4024 24.226C44.9649 24.6674 44.3672 24.9135 43.7462 24.9135Z" fill="currentColor"/>' },
      jungle: { viewBox: '0 0 640 512', path: '<path d="M448.76 64c-39.43 0-75.06 11.74-103 30.5C327.14 40.17 265.37 0 191.24 0c-80.62 0-147.37 47.24-159 108.86C30.39 118.79 38.75 128 50 128h54l24-48 33.46 66.92c-3.53 3.07-7.28 5.69-10.66 9.07C93.8 213 80 293.6 115.37 345.38c5.7 8.34 18.12 8.94 26.07 1l146.13-146.14c10.72 104.75-11.42 215-25.85 272.15C256.64 492.52 272 512 292.8 512h55.13c15.75 0 29.67-11.37 31.71-27 14.79-113.47-11.57-236.34-26.41-293H488l24-48 24 48h54c11.25 0 19.61-9.21 17.74-19.14C596.13 111.24 529.38 64 448.76 64z" fill="currentColor"/>' },
      volcanic: { viewBox: '0 0 384 512', path: '<path d="M216 23.86c0-23.8-30.65-32.77-44.15-13.04C48 191.85 224 200 224 288c0 35.63-29.11 64.46-64.85 63.99-35.17-.45-63.15-29.77-63.15-64.94v-85.51c0-21.7-26.47-32.23-41.43-16.5C27.8 213.16 0 261.33 0 320c0 105.87 86.13 192 192 192s192-86.13 192-192c0-170.29-168-193-168-296.14z" fill="currentColor"/>' },
      arctic: { viewBox: '0 0 512 512', path: '<path d="M511.4 37.9C515.1 18.2 500 0 480 0H32C10.6 0-4.8 20.7 1.4 41.2l87.1 273.4c2.5 7.2 12.7 7.2 15.1 0L140 190.5l44.2 187.3c1.9 8.3 13.7 8.3 15.6 0l46.5-196.9 34.1 133.4c2.3 7.6 13 7.6 15.3 0l45.8-172.5 66.7 363.8c1.7 8.6 14 8.6 15.7 0l87.5-467.7z" fill="currentColor"/>' },
      savanna: { viewBox: '0 0 640 512', path: '<path d="M512 32c-13.16 0-25.52 2.66-37.4 6.4C464.71 15.82 442.23 0 416 0c-35.35 0-64 28.65-64 64 0 23.63 12.95 44.04 32 55.12V160c0 17.67 14.33 32 32 32h8c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8h-8c-35.29 0-64-28.71-64-64v-24.8c-20.08-18.03-32-43.92-32-71.2 0-11.28 2.31-21.94 5.9-32H192C85.96 32 0 117.96 0 224v112c0 8.84 7.16 16 16 16h16v144c0 8.84 7.16 16 16 16h64c8.84 0 16-7.16 16-16V388.15C160.35 405.7 198.72 416 240 416s79.65-10.3 112-27.85V496c0 8.84 7.16 16 16 16h64c8.84 0 16-7.16 16-16V288h64c23.44 0 45.11-6.76 64-17.75V368c0 8.83-7.17 16-16 16s-16-7.17-16-16c0-8.84-7.16-16-16-16h-32c-8.84 0-16 7.16-16 16 0 46.87 40.52 84.46 88.36 79.57 41.62-4.25 71.64-42.46 71.64-84.3V160c0-70.69-57.31-128-128-128zm16 128c-8.84 0-16-7.16-16-16s7.16-16 16-16 16 7.16 16 16-7.16 16-16 16z" fill="currentColor"/>' },
      cavern: { viewBox: '0 0 640 512', path: '<path d="M558.44 129.7c-7.64-17.82-29.25-24.81-45.88-14.83L411.83 175.3 384 64l-42.67 32h-42.67L256 64l-27.83 111.3-100.74-60.44c-16.63-9.98-38.24-2.99-45.88 14.83L0 320l49.62-16.54c27.38-9.13 57.48 1.2 73.49 25.21L160 384l11.82-11.82c27.54-27.54 73.09-24.3 96.46 6.85L320 448l51.72-68.97c23.37-31.16 68.91-34.39 96.46-6.85L480 384l36.88-55.33c16.01-24.01 46.11-34.34 73.49-25.21L640 320l-81.56-190.3z" fill="currentColor"/>' },
    };

    // Temperature feel based on biome base temp + weather modifier
    const BIOME_TEMPS = {
      forest: 'mild',
      desert: 'hot',
      tundra: 'cold',
      swamp: 'warm',
      mountains: 'cool',
      plains: 'mild',
      coast: 'mild',
      jungle: 'hot',
      volcanic: 'scorching',
      arctic: 'freezing',
      savanna: 'hot',
      cavern: 'cool'
    };

    const TEMP_MODIFIERS = {
      clear: 0, cloudy: -1, rain: -1, fog: -1, storm: -2,
      windy: 0, hot: 2, sandstorm: 1, snow: -2, blizzard: -3,
      foggy: -1, humid: 1, downpour: -1, misty: 0,
      ash: 1, smoke: 1, fiery: 3, ice_storm: -3,
      dry: 1, dust: 0, dark: 0, damp: -1, dripping: -1
    };

    const TEMP_SCALE = ['freezing', 'frigid', 'cold', 'chilly', 'cool', 'mild', 'warm', 'pleasant', 'hot', 'sweltering', 'scorching'];

    function getTempFeel() {
      const baseTemps = { freezing: 0, cold: 2, cool: 4, mild: 5, warm: 7, hot: 8, scorching: 10 };
      const baseIndex = baseTemps[BIOME_TEMPS[currentBiome]] || 5;
      const modifier = TEMP_MODIFIERS[currentWeather] || 0;
      const finalIndex = Math.max(0, Math.min(TEMP_SCALE.length - 1, baseIndex + modifier));
      return TEMP_SCALE[finalIndex].charAt(0).toUpperCase() + TEMP_SCALE[finalIndex].slice(1);
    }

    // Wind descriptions based on weather
    const WIND_LEVELS = {
      clear: 'Calm', cloudy: 'Light breeze', rain: 'Gusty', fog: 'Still',
      storm: 'Strong winds', windy: 'Howling winds', hot: 'Calm',
      sandstorm: 'Violent gusts', snow: 'Light breeze', blizzard: 'Gale force',
      foggy: 'Still', humid: 'Stagnant', downpour: 'Heavy gusts', misty: 'Gentle',
      ash: 'Swirling', smoke: 'Light drift', fiery: 'Intense drafts',
      ice_storm: 'Biting winds', dry: 'Calm', dust: 'Breezy',
      dark: 'Still', damp: 'Stagnant', dripping: 'Still'
    };

    function getWindSpeed() {
      return WIND_LEVELS[currentWeather] || 'Light breeze';
    }


    // State
    let currentBiome = 'forest';
    let currentWeather = 'clear';
    let currentTime = 'morning';
    let particleSystem = null;

    // Particle system class
    class WeatherParticles {
      constructor(container, scale = 1) {
        this.container = container;
        this.scale = scale;
        this.baseWidth = 329;
        this.baseHeight = 155;
        this.width = this.baseWidth * scale;
        this.height = this.baseHeight * scale;
        this.running = false;
        this.type = 'none';
        this.spawnInterval = null;
      }

      // Scale helper - multiplies value by scale factor
      s(value) {
        return value * this.scale;
      }

      setType(type) {
        this.type = type;
        this.container.innerHTML = '';
        if (this.spawnInterval) {
          clearInterval(this.spawnInterval);
          this.spawnInterval = null;
        }
        if (this.running && type !== 'none') {
          // Pre-spawn particles so they're already visible when weather loads
          this.prespawnParticles(type);
          this.startSpawning();
        }
      }

      prespawnParticles(type) {
        const width = this.width;
        const height = this.height;
        const s = (v) => this.s(v);

        // Determine count and spawn based on type
        const configs = {
          clouds: { count: [4, 3] },
          rays: { count: [12, 7] }, // stars for night, or rays for day
          rain: { count: [15, 10] },
          storm: { count: [20, 10] },
          downpour: { count: [25, 15] },
          snow: { count: [12, 8] },
          blizzard: { count: [20, 10] },
          fog: { count: [8, 5] },
          mist: { count: [6, 4] },
          sand: { count: [10, 8] },
          dust: { count: [8, 5] },
          ash: { count: [8, 5] },
          smoke: { count: [6, 4] },
          sparks: { count: [6, 4] },
          wind: { count: [5, 3] },
          heat: { count: [4, 3] },
          ice: { count: [12, 8] },
          drip: { count: [4, 3] }
        };

        const config = configs[type];
        if (!config) return;

        const count = config.count[0] + Math.floor(Math.random() * config.count[1]);

        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';

          // Position particle mid-flight based on type
          const progress = Math.random(); // 0-1 representing how far along the animation

          switch (type) {
            case 'clouds':
              particle.classList.add('cloud');
              const cloudWidth = s(100 + Math.random() * 150);
              const cloudHeight = s(50 + Math.random() * 70);
              particle.style.width = cloudWidth + 'px';
              particle.style.height = cloudHeight + 'px';
              particle.style.left = (progress * width) + 'px';
              particle.style.top = (Math.random() * height * 0.7) + 'px';
              particle.style.opacity = '0.5';
              const cloudRemaining = width + cloudWidth - (progress * width);
              particle.animate([
                { transform: 'translateX(0)', opacity: 0.5 },
                { transform: `translateX(${cloudRemaining + s(50)}px)`, opacity: 0 }
              ], {
                duration: (1 - progress) * (20000 + Math.random() * 15000),
                easing: 'linear'
              }).onfinish = () => particle.remove();
              break;

            case 'rays':
              const isNight = currentTime === 'evening' || currentTime === 'night';
              if (isNight) {
                particle.classList.add('star');
                const starSize = s(0.5 + Math.random() * 1);
                particle.style.width = starSize + 'px';
                particle.style.height = starSize + 'px';
                particle.style.left = (Math.random() * width) + 'px';
                particle.style.top = (s(5) + Math.random() * height * 0.35) + 'px';
                const maxOpacity = 0.4 + Math.random() * 0.5;
                particle.style.opacity = maxOpacity;
                particle.animate([
                  { opacity: maxOpacity, transform: 'scale(1)' },
                  { opacity: maxOpacity * 0.7, transform: 'scale(0.95)', offset: 0.4 },
                  { opacity: maxOpacity, transform: 'scale(1)', offset: 0.7 },
                  { opacity: 0, transform: 'scale(0.8)' }
                ], {
                  duration: 4000 + Math.random() * 4000,
                  easing: 'ease-in-out'
                }).onfinish = () => particle.remove();
              } else {
                particle.classList.add('ray');
                // Keep ray width thin (don't scale) to preserve tapered effect
                const rayWidth = 8 + Math.random() * 15;
                // Longer rays that stretch toward bottom edge
                const rayHeight = s(180 + Math.random() * 80);
                particle.style.width = rayWidth + 'px';
                particle.style.height = rayHeight + 'px';
                // Rays emanate from top-right corner (sun position)
                // Spread rays across the widget, originating from top-right
                const rayProgress = Math.random(); // 0 = far right, 1 = far left
                const rayX = width * 0.95 - rayProgress * width * 0.9;
                particle.style.left = rayX + 'px';
                particle.style.top = s(-20) + 'px';
                // Angle increases as rays go further left (fan out from sun)
                // Right side rays: ~15deg, Left side rays: ~45deg
                const angle = 15 + rayProgress * 30 + (Math.random() - 0.5) * 10;
                particle.style.transform = `rotate(${angle}deg)`;
                particle.style.transformOrigin = 'top center';
                particle.style.opacity = 0.3 + Math.random() * 0.2;
                particle.animate([
                  { opacity: 0.4, transform: `rotate(${angle}deg) scaleY(1)` },
                  { opacity: 0, transform: `rotate(${angle}deg) scaleY(0.8)` }
                ], {
                  duration: (1 - progress) * (3500 + Math.random() * 2000),
                  easing: 'ease-in-out'
                }).onfinish = () => particle.remove();
              }
              break;

            case 'rain':
            case 'storm':
            case 'downpour':
              particle.classList.add('rain');
              const rainIntensity = type === 'downpour' ? 1.8 : type === 'storm' ? 1.4 : 1;
              const windAngle = type === 'storm' ? 20 + Math.random() * 10 : 12 + Math.random() * 6;
              const fallDistance = height - progress * height + s(30);
              const horizontalDrift = Math.tan(windAngle * Math.PI / 180) * fallDistance;
              particle.style.left = Math.random() * width + 'px';
              particle.style.top = (progress * height) + 'px';
              particle.style.height = s((18 + Math.random() * 14) * rainIntensity) + 'px';
              particle.style.transform = `rotate(${-windAngle}deg)`;
              particle.style.opacity = 0.6;
              particle.animate([
                { transform: `translate(0, 0) rotate(${-windAngle}deg)`, opacity: 0.6 },
                { transform: `translate(${horizontalDrift}px, ${fallDistance}px) rotate(${-windAngle}deg)`, opacity: 0.3 }
              ], {
                duration: (1 - progress) * (type === 'downpour' ? 250 : type === 'storm' ? 300 : 400),
                easing: 'linear'
              }).onfinish = () => particle.remove();
              break;

            case 'snow':
            case 'blizzard':
              particle.classList.add('snowflake');
              const snowSize = s(type === 'blizzard' ? 4 + Math.random() * 5 : 3 + Math.random() * 4);
              particle.style.width = snowSize + 'px';
              particle.style.height = snowSize + 'px';
              const drift = s(type === 'blizzard' ? 120 + Math.random() * 180 : 30 + Math.random() * 50);
              particle.style.left = (Math.random() * width) + 'px';
              particle.style.top = (progress * height) + 'px';
              particle.style.opacity = 0.8;
              particle.animate([
                { transform: `translate(0, 0) rotate(${progress * 360}deg)`, opacity: 0.8 },
                { transform: `translate(${drift * (1 - progress)}px, ${height - progress * height + s(20)}px) rotate(360deg)`, opacity: 0.3 }
              ], {
                duration: (1 - progress) * (type === 'blizzard' ? 800 : 2500),
                easing: 'ease-in-out'
              }).onfinish = () => particle.remove();
              break;

            case 'fog':
            case 'mist':
              if (Math.random() < 0.8) {
                particle.classList.add('fog');
                const fogWidth = s(40 + Math.random() * 80);
                particle.style.width = fogWidth + 'px';
                particle.style.height = s(1 + Math.random() * 2) + 'px';
                particle.style.left = (progress * width) + 'px';
                particle.style.top = Math.random() * height + 'px';
                const peakOpacity = type === 'fog' ? 0.15 : 0.1;
                particle.style.opacity = peakOpacity;
                particle.animate([
                  { transform: 'translateX(0)', opacity: peakOpacity },
                  { transform: `translateX(${width - progress * width + fogWidth + s(50)}px)`, opacity: 0 }
                ], {
                  duration: (1 - progress) * (12000 + Math.random() * 8000),
                  easing: 'linear'
                }).onfinish = () => particle.remove();
              } else {
                particle.classList.add('fogbank');
                const bankWidth = s(80 + Math.random() * 120);
                const bankHeight = s(25 + Math.random() * 35);
                particle.style.width = bankWidth + 'px';
                particle.style.height = bankHeight + 'px';
                particle.style.left = (progress * width) + 'px';
                particle.style.top = (Math.random() * (height - bankHeight)) + 'px';
                const peakOpacity = type === 'fog' ? 0.2 : 0.12;
                particle.style.opacity = peakOpacity;
                particle.animate([
                  { transform: 'translateX(0) scale(1)', opacity: peakOpacity },
                  { transform: `translateX(${width - progress * width + bankWidth + s(30)}px) scale(0.9)`, opacity: 0 }
                ], {
                  duration: (1 - progress) * (18000 + Math.random() * 10000),
                  easing: 'linear'
                }).onfinish = () => particle.remove();
              }
              break;

            case 'sand':
            case 'dust':
              particle.classList.add('sand');
              const sandSize = s(type === 'sand' ? 2 + Math.random() * 3 : 1.5 + Math.random() * 2);
              particle.style.width = sandSize + 'px';
              particle.style.height = (sandSize * 0.6) + 'px';
              particle.style.left = (progress * width) + 'px';
              particle.style.top = Math.random() * height + 'px';
              particle.style.opacity = 0.6;
              particle.animate([
                { transform: 'translateX(0)', opacity: 0.6 },
                { transform: `translateX(${width - progress * width + s(30)}px)`, opacity: 0 }
              ], {
                duration: (1 - progress) * (type === 'sand' ? 500 : 800),
                easing: 'linear'
              }).onfinish = () => particle.remove();
              break;

            case 'ash':
            case 'smoke':
              particle.classList.add('ash');
              particle.style.left = Math.random() * width + 'px';
              particle.style.top = (height - progress * height) + 'px';
              particle.style.opacity = 0.5;
              particle.animate([
                { transform: 'translate(0, 0)', opacity: 0.5 },
                { transform: `translate(${s((Math.random() - 0.5) * 60)}px, -${height - progress * height + s(30)}px)`, opacity: 0 }
              ], {
                duration: (1 - progress) * (3000 + Math.random() * 2000),
                easing: 'ease-out'
              }).onfinish = () => particle.remove();
              break;

            case 'sparks':
              particle.classList.add('ember');
              const emberSize = s(3 + Math.random() * 4);
              particle.style.width = emberSize + 'px';
              particle.style.height = emberSize + 'px';
              particle.style.left = Math.random() * width + 'px';
              particle.style.top = (height - progress * height) + 'px';
              particle.style.opacity = 0.8;
              particle.animate([
                { transform: 'translate(0, 0) scale(0.8)', opacity: 0.8 },
                { transform: `translate(${s((Math.random() - 0.5) * 100)}px, -${height - progress * height + s(30)}px) scale(0.2)`, opacity: 0 }
              ], {
                duration: (1 - progress) * (2500 + Math.random() * 1500),
                easing: 'ease-out'
              }).onfinish = () => particle.remove();
              break;

            case 'wind':
              particle.style.width = s(30 + Math.random() * 40) + 'px';
              particle.style.height = s(1) + 'px';
              particle.style.background = 'linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent)';
              particle.style.left = (progress * width) + 'px';
              particle.style.top = Math.random() * height + 'px';
              particle.style.opacity = 0.3;
              particle.animate([
                { transform: 'translateX(0)', opacity: 0.3 },
                { transform: `translateX(${width - progress * width + s(100)}px)`, opacity: 0 }
              ], {
                duration: (1 - progress) * (800 + Math.random() * 400),
                easing: 'linear'
              }).onfinish = () => particle.remove();
              break;

            case 'heat':
              particle.style.width = s(40) + 'px';
              particle.style.height = s(2) + 'px';
              particle.style.background = 'linear-gradient(90deg, transparent, rgba(255,200,100,0.2), transparent)';
              particle.style.left = Math.random() * width + 'px';
              particle.style.top = (height - progress * s(60)) + 'px';
              particle.style.opacity = 0.2;
              particle.animate([
                { transform: 'translateY(0) scaleX(1)', opacity: 0.2 },
                { transform: `translateY(-${s(60) - progress * s(60)}px) scaleX(0.8)`, opacity: 0 }
              ], {
                duration: (1 - progress) * (2000 + Math.random() * 1000),
                easing: 'ease-out'
              }).onfinish = () => particle.remove();
              break;

            case 'ice':
              particle.classList.add('snow');
              particle.style.width = s(3) + 'px';
              particle.style.height = s(8) + 'px';
              particle.style.borderRadius = s(1) + 'px';
              particle.style.left = Math.random() * width + 'px';
              particle.style.top = (progress * height) + 'px';
              particle.style.opacity = 0.7;
              particle.animate([
                { transform: 'translateY(0) rotate(30deg)', opacity: 0.7 },
                { transform: `translateY(${height - progress * height + s(20)}px) rotate(30deg)`, opacity: 0.3 }
              ], {
                duration: (1 - progress) * (500 + Math.random() * 200),
                easing: 'linear'
              }).onfinish = () => particle.remove();
              break;

            case 'drip':
              particle.classList.add('drip');
              particle.style.left = Math.random() * width + 'px';
              particle.style.top = (progress * height) + 'px';
              particle.style.opacity = 0.5;
              particle.animate([
                { transform: 'translateY(0)', opacity: 0.5 },
                { transform: `translateY(${height - progress * height + s(20)}px)`, opacity: 0.2 }
              ], {
                duration: (1 - progress) * (1500 + Math.random() * 500),
                easing: 'ease-in'
              }).onfinish = () => particle.remove();
              break;
          }

          this.container.appendChild(particle);
        }
      }

      start() {
        this.running = true;
        if (this.type !== 'none') {
          this.startSpawning();
        }
      }

      stop() {
        this.running = false;
        if (this.spawnInterval) {
          clearInterval(this.spawnInterval);
          this.spawnInterval = null;
        }
      }

      startSpawning() {
        const rates = {
          rain: 40,
          storm: 25,
          downpour: 15,
          snow: 80,
          blizzard: 30,
          fog: 80,
          mist: 200,
          sand: 35,
          dust: 50,
          ash: 100,
          smoke: 120,
          sparks: 120,
          rays: 150,
          clouds: 400,
          wind: 50,
          heat: 200,
          ice: 40,
          drip: 300
        };

        const rate = rates[this.type] || 100;
        this.spawnInterval = setInterval(() => {
          if (this.running) this.createParticle();
        }, rate);
      }

      createParticle() {
        const particle = document.createElement('div');
        particle.className = 'particle';

        const width = this.width;
        const height = this.height;
        const s = (v) => this.s(v);

        switch (this.type) {
          case 'rain':
          case 'storm':
          case 'downpour':
            // 85% raindrops, 15% splashes at bottom
            if (Math.random() < 0.85) {
              particle.classList.add('rain');
              const rainIntensity = this.type === 'downpour' ? 1.8 : this.type === 'storm' ? 1.4 : 1;
              const windAngle = this.type === 'storm' ? 20 + Math.random() * 10 : 12 + Math.random() * 6;
              const totalFall = height + s(30);
              const rainDrift = Math.tan(windAngle * Math.PI / 180) * totalFall;
              particle.style.left = Math.random() * width + 'px';
              particle.style.top = s(-15) + 'px';
              particle.style.height = s((18 + Math.random() * 14) * rainIntensity) + 'px';
              particle.style.transform = `rotate(${-windAngle}deg)`;
              particle.style.opacity = 0.6 + Math.random() * 0.3;
              const speed = this.type === 'downpour' ? 250 : this.type === 'storm' ? 300 : 400;
              particle.animate([
                { transform: `translate(0, 0) rotate(${-windAngle}deg)`, opacity: 0.7 },
                { transform: `translate(${rainDrift}px, ${totalFall}px) rotate(${-windAngle}deg)`, opacity: 0.35 }
              ], {
                duration: speed + Math.random() * 150,
                easing: 'linear'
              }).onfinish = () => particle.remove();
            } else {
              // Splash effect at bottom
              particle.classList.add('splash');
              const splashX = Math.random() * width;
              particle.style.left = splashX + 'px';
              particle.style.top = (height - s(15) + Math.random() * s(10)) + 'px';
              particle.animate([
                { transform: 'scale(0) translateY(0)', opacity: 0.7 },
                { transform: `scale(${this.scale * 1.5}) translateY(${s(-3)}px)`, opacity: 0.5, offset: 0.3 },
                { transform: `scale(${this.scale * 2}) translateY(${s(-1)}px)`, opacity: 0 }
              ], {
                duration: 300 + Math.random() * 100,
                easing: 'ease-out'
              }).onfinish = () => particle.remove();
            }
            break;

          case 'snow':
          case 'blizzard':
            particle.classList.add('snowflake');
            const snowSize = s(this.type === 'blizzard' ? 4 + Math.random() * 5 : 3 + Math.random() * 4);
            particle.style.width = snowSize + 'px';
            particle.style.height = snowSize + 'px';
            particle.style.left = Math.random() * width + 'px';
            particle.style.top = s(-10) + 'px';
            const drift = s(this.type === 'blizzard' ? 120 + Math.random() * 180 : 30 + Math.random() * 50);
            const dur = this.type === 'blizzard' ? 800 + Math.random() * 400 : 2500 + Math.random() * 1500;
            // Add gentle wobble for realistic floating
            const wobble1 = s((Math.random() - 0.5) * 20);
            const wobble2 = s((Math.random() - 0.5) * 25);
            particle.animate([
              { transform: 'translate(0, 0) rotate(0deg)', opacity: 0 },
              { transform: `translate(${drift * 0.2 + wobble1}px, ${height * 0.25}px) rotate(90deg)`, opacity: 0.9, offset: 0.25 },
              { transform: `translate(${drift * 0.5 + wobble2}px, ${height * 0.5}px) rotate(180deg)`, opacity: 0.85, offset: 0.5 },
              { transform: `translate(${drift * 0.8 + wobble1}px, ${height * 0.75}px) rotate(270deg)`, opacity: 0.7, offset: 0.75 },
              { transform: `translate(${drift}px, ${height + s(20)}px) rotate(360deg)`, opacity: 0.3 }
            ], {
              duration: dur,
              easing: 'ease-in-out'
            }).onfinish = () => particle.remove();
            break;

          case 'fog':
          case 'mist':
            // 80% wispy streaks, 20% larger fog banks - more quantity, less density
            if (Math.random() < 0.8) {
              particle.classList.add('fog');
              const fogWidth = s(40 + Math.random() * 80);
              particle.style.width = fogWidth + 'px';
              particle.style.height = s(1 + Math.random() * 2) + 'px';
              particle.style.left = '-' + fogWidth + 'px';
              particle.style.top = Math.random() * height + 'px';
              const peakOpacity = this.type === 'fog' ? 0.15 : 0.1;
              const yDrift = s((Math.random() - 0.5) * 30);
              particle.animate([
                { transform: 'translateX(0) translateY(0) scaleY(1)', opacity: 0 },
                { transform: `translateX(${width * 0.3}px) translateY(${yDrift * 0.3}px) scaleY(1.2)`, opacity: peakOpacity, offset: 0.3 },
                { transform: `translateX(${width * 0.6}px) translateY(${yDrift * 0.7}px) scaleY(0.9)`, opacity: peakOpacity * 0.8, offset: 0.6 },
                { transform: `translateX(${width + fogWidth + s(50)}px) translateY(${yDrift}px) scaleY(1)`, opacity: 0 }
              ], {
                duration: 12000 + Math.random() * 8000,
                easing: 'ease-in-out'
              }).onfinish = () => particle.remove();
            } else {
              // Larger fog bank - more subtle
              particle.classList.add('fogbank');
              const bankWidth = s(80 + Math.random() * 120);
              const bankHeight = s(25 + Math.random() * 35);
              particle.style.width = bankWidth + 'px';
              particle.style.height = bankHeight + 'px';
              particle.style.left = '-' + bankWidth + 'px';
              particle.style.top = (Math.random() * (height - bankHeight)) + 'px';
              const peakOpacity = this.type === 'fog' ? 0.2 : 0.12;
              particle.animate([
                { transform: 'translateX(0) scale(0.8)', opacity: 0 },
                { transform: `translateX(${width * 0.4}px) scale(1.1)`, opacity: peakOpacity, offset: 0.4 },
                { transform: `translateX(${width + bankWidth + s(30)}px) scale(0.9)`, opacity: 0 }
              ], {
                duration: 18000 + Math.random() * 10000,
                easing: 'ease-in-out'
              }).onfinish = () => particle.remove();
            }
            break;

          case 'sand':
          case 'dust':
            particle.classList.add('sand');
            const sandSize = s(this.type === 'sand' ? 2 + Math.random() * 3 : 1.5 + Math.random() * 2);
            particle.style.width = sandSize + 'px';
            particle.style.height = (sandSize * 0.6) + 'px';
            particle.style.left = s(-10) + 'px';
            particle.style.top = Math.random() * height + 'px';
            const sandSpeed = this.type === 'sand' ? 500 : 800;
            const yWave1 = s((Math.random() - 0.5) * 15);
            const yWave2 = s((Math.random() - 0.5) * 20);
            const yWave3 = s((Math.random() - 0.5) * 15);
            particle.animate([
              { transform: 'translate(0, 0) rotate(0deg)', opacity: 0 },
              { transform: `translate(${width * 0.25}px, ${yWave1}px) rotate(180deg)`, opacity: 0.75, offset: 0.25 },
              { transform: `translate(${width * 0.5}px, ${yWave2}px) rotate(360deg)`, opacity: 0.7, offset: 0.5 },
              { transform: `translate(${width * 0.75}px, ${yWave3}px) rotate(540deg)`, opacity: 0.5, offset: 0.75 },
              { transform: `translate(${width + s(30)}px, ${s((Math.random() - 0.5) * 25)}px) rotate(720deg)`, opacity: 0 }
            ], {
              duration: sandSpeed + Math.random() * 300,
              easing: 'ease-in-out'
            }).onfinish = () => particle.remove();
            break;

          case 'ash':
          case 'smoke':
            particle.classList.add('ash');
            particle.style.left = Math.random() * width + 'px';
            particle.style.top = height + s(10) + 'px';
            const driftX = s((Math.random() - 0.5) * 60);
            particle.animate([
              { transform: 'translate(0, 0)', opacity: 0 },
              { transform: `translate(${driftX * 0.3}px, -${height * 0.3}px)`, opacity: 0.6, offset: 0.3 },
              { transform: `translate(${driftX}px, -${height + s(30)}px)`, opacity: 0 }
            ], {
              duration: 3000 + Math.random() * 2000,
              easing: 'ease-out'
            }).onfinish = () => particle.remove();
            break;

          case 'sparks':
            // 60% glowing embers, 40% quick sparks
            if (Math.random() < 0.6) {
              particle.classList.add('ember');
              const emberSize = s(3 + Math.random() * 4);
              particle.style.width = emberSize + 'px';
              particle.style.height = emberSize + 'px';
              particle.style.left = Math.random() * width + 'px';
              particle.style.top = height + s(5) + 'px';
              const emberDriftX = s((Math.random() - 0.5) * 100);
              const wobbleX = s((Math.random() - 0.5) * 30);
              particle.animate([
                { transform: 'translate(0, 0) scale(0.5)', opacity: 0 },
                { transform: `translate(${emberDriftX * 0.3 + wobbleX}px, -${height * 0.3}px) scale(1)`, opacity: 1, offset: 0.2 },
                { transform: `translate(${emberDriftX * 0.6 - wobbleX}px, -${height * 0.6}px) scale(0.9)`, opacity: 0.9, offset: 0.5 },
                { transform: `translate(${emberDriftX * 0.8 + wobbleX}px, -${height * 0.85}px) scale(0.6)`, opacity: 0.6, offset: 0.8 },
                { transform: `translate(${emberDriftX}px, -${height + s(30)}px) scale(0.2)`, opacity: 0 }
              ], {
                duration: 2500 + Math.random() * 1500,
                easing: 'ease-out'
              }).onfinish = () => particle.remove();
            } else {
              particle.classList.add('spark');
              particle.style.left = Math.random() * width + 'px';
              particle.style.top = height + s(5) + 'px';
              const sparkDriftX = s((Math.random() - 0.5) * 60);
              particle.animate([
                { transform: 'translate(0, 0) scale(1)', opacity: 0.9 },
                { transform: `translate(${sparkDriftX * 0.4}px, -${height * 0.4}px) scale(0.7)`, opacity: 1, offset: 0.4 },
                { transform: `translate(${sparkDriftX}px, -${height + s(10)}px) scale(0.2)`, opacity: 0 }
              ], {
                duration: 1000 + Math.random() * 600,
                easing: 'ease-out'
              }).onfinish = () => particle.remove();
            }
            break;

          case 'rays':
            // Check if it's evening/night - show stars instead of sun rays
            const isNightTime = currentTime === 'evening' || currentTime === 'night';

            if (isNightTime) {
              // Twinkling star - small and distant
              particle.classList.add('star');
              const starSize = s(0.5 + Math.random() * 1);
              particle.style.width = starSize + 'px';
              particle.style.height = starSize + 'px';
              particle.style.left = (Math.random() * width) + 'px';
              particle.style.top = (s(5) + Math.random() * height * 0.35) + 'px';
              const twinkleDuration = 4000 + Math.random() * 4000;
              const maxOpacity = 0.4 + Math.random() * 0.5;
              particle.animate([
                { opacity: 0, transform: 'scale(0.8)' },
                { opacity: maxOpacity, transform: 'scale(1)', offset: 0.4 },
                { opacity: maxOpacity * 0.7, transform: 'scale(0.95)', offset: 0.6 },
                { opacity: maxOpacity, transform: 'scale(1)', offset: 0.8 },
                { opacity: 0, transform: 'scale(0.8)' }
              ], {
                duration: twinkleDuration,
                easing: 'ease-in-out'
              }).onfinish = () => particle.remove();
            } else {
              const rand = Math.random();
              if (rand < 0.15) {
                // Subtle dust particles
                particle.classList.add('sundust');
                const dustSize = s(1 + Math.random() * 1.5);
                particle.style.width = dustSize + 'px';
                particle.style.height = dustSize + 'px';
                const dustX = s(30) + Math.random() * (width - s(60));
                const dustY = s(20) + Math.random() * (height - s(50));
                particle.style.left = dustX + 'px';
                particle.style.top = dustY + 'px';
                const driftX2 = s((Math.random() - 0.5) * 15);
                const driftY = s(-5 - Math.random() * 10);
                particle.animate([
                  { transform: 'translate(0, 0)', opacity: 0 },
                  { transform: `translate(${driftX2 * 0.5}px, ${driftY * 0.5}px)`, opacity: 0.4, offset: 0.4 },
                  { transform: `translate(${driftX2}px, ${driftY}px)`, opacity: 0 }
                ], {
                  duration: 4000 + Math.random() * 2000,
                  easing: 'ease-in-out'
                }).onfinish = () => particle.remove();
              } else {
                // Dramatic god ray - emanating from top-right (sun position)
                particle.classList.add('ray');
                // Keep ray width thin (don't scale) to preserve tapered effect
                const rayWidth = 8 + Math.random() * 15;
                // Longer rays that stretch toward bottom edge
                const rayHeight = s(180 + Math.random() * 80);
                particle.style.width = rayWidth + 'px';
                particle.style.height = rayHeight + 'px';
                // Rays emanate from top-right corner (sun position)
                // Spread rays across the widget, originating from top-right
                const rayProgress = Math.random(); // 0 = far right, 1 = far left
                const rayX = width * 0.95 - rayProgress * width * 0.9;
                particle.style.left = rayX + 'px';
                particle.style.top = s(-20) + 'px';
                // Angle increases as rays go further left (fan out from sun)
                // Right side rays: ~15deg, Left side rays: ~45deg
                const angle = 15 + rayProgress * 30 + (Math.random() - 0.5) * 10;
                particle.style.transform = `rotate(${angle}deg)`;
                particle.style.transformOrigin = 'top center';
                particle.animate([
                  { opacity: 0, transform: `rotate(${angle}deg) scaleY(0.7)` },
                  { opacity: 0.5, transform: `rotate(${angle}deg) scaleY(1)`, offset: 0.3 },
                  { opacity: 0.4, transform: `rotate(${angle}deg) scaleY(1)`, offset: 0.7 },
                  { opacity: 0, transform: `rotate(${angle}deg) scaleY(0.8)` }
                ], {
                  duration: 3500 + Math.random() * 2000,
                  easing: 'ease-in-out'
                }).onfinish = () => particle.remove();
              }
            }
            break;

          case 'clouds':
            // Slow drifting clouds
            particle.classList.add('cloud');
            const cloudWidth = s(100 + Math.random() * 150);
            const cloudHeight = s(50 + Math.random() * 70);
            particle.style.width = cloudWidth + 'px';
            particle.style.height = cloudHeight + 'px';
            particle.style.left = -cloudWidth + 'px';
            particle.style.top = (Math.random() * height * 0.7) + 'px';
            particle.animate([
              { transform: 'translateX(0)', opacity: 0 },
              { transform: `translateX(${width * 0.15}px)`, opacity: 0.5, offset: 0.1 },
              { transform: `translateX(${width * 0.85}px)`, opacity: 0.5, offset: 0.9 },
              { transform: `translateX(${width + cloudWidth + s(50)}px)`, opacity: 0 }
            ], {
              duration: 20000 + Math.random() * 15000,
              easing: 'linear'
            }).onfinish = () => particle.remove();
            break;

          case 'wind':
            particle.style.width = s(30 + Math.random() * 40) + 'px';
            particle.style.height = s(1) + 'px';
            particle.style.background = 'linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent)';
            particle.style.left = s(-50) + 'px';
            particle.style.top = Math.random() * height + 'px';
            particle.animate([
              { transform: 'translateX(0)', opacity: 0 },
              { transform: `translateX(${s(100)}px)`, opacity: 0.4, offset: 0.3 },
              { transform: `translateX(${width + s(100)}px)`, opacity: 0 }
            ], {
              duration: 800 + Math.random() * 400,
              easing: 'linear'
            }).onfinish = () => particle.remove();
            break;

          case 'heat':
            particle.style.width = s(40) + 'px';
            particle.style.height = s(2) + 'px';
            particle.style.background = 'linear-gradient(90deg, transparent, rgba(255,200,100,0.2), transparent)';
            particle.style.left = Math.random() * width + 'px';
            particle.style.top = height + 'px';
            particle.animate([
              { transform: 'translateY(0) scaleX(1)', opacity: 0 },
              { transform: `translateY(${s(-30)}px) scaleX(1.2)`, opacity: 0.3, offset: 0.5 },
              { transform: `translateY(${s(-60)}px) scaleX(0.8)`, opacity: 0 }
            ], {
              duration: 2000 + Math.random() * 1000,
              easing: 'ease-out'
            }).onfinish = () => particle.remove();
            break;

          case 'ice':
            particle.classList.add('snow');
            particle.style.width = s(3) + 'px';
            particle.style.height = s(8) + 'px';
            particle.style.borderRadius = s(1) + 'px';
            particle.style.left = Math.random() * width + 'px';
            particle.style.top = s(-10) + 'px';
            particle.animate([
              { transform: 'translateY(0) rotate(30deg)', opacity: 0.8 },
              { transform: `translateY(${height + s(20)}px) rotate(30deg)`, opacity: 0.4 }
            ], {
              duration: 500 + Math.random() * 200,
              easing: 'linear'
            }).onfinish = () => particle.remove();
            break;

          case 'drip':
            particle.classList.add('drip');
            particle.style.left = Math.random() * width + 'px';
            particle.style.top = s(-8) + 'px';
            particle.animate([
              { transform: 'translateY(0)', opacity: 0 },
              { transform: `translateY(${s(20)}px)`, opacity: 0.6, offset: 0.3 },
              { transform: `translateY(${height + s(20)}px)`, opacity: 0.3 }
            ], {
              duration: 1500 + Math.random() * 500,
              easing: 'ease-in'
            }).onfinish = () => particle.remove();
            break;
        }

        this.container.appendChild(particle);
      }
    }

    // Lightning flash for storms
    function triggerLightning() {
      const lightning = document.getElementById('lightning');
      lightning.classList.add('active');
      setTimeout(() => lightning.classList.remove('active'), 150);
    }

    let stormInterval = null;

    // Update the widget display
    function updateWidget() {
      const widget = document.getElementById('weatherWidget');
      const weatherInfo = WEATHER_INFO[currentWeather] || { name: currentWeather, detail: '', particles: 'none' };

      // Update biome class
      widget.className = `widget biome-${currentBiome} time-${currentTime} loaded`;

      // Update biome badge (icon + label)
      const biomeIconData = BIOME_ICONS[currentBiome] || BIOME_ICONS.forest;
      const biomeIconEl = document.getElementById('biomeIcon');
      biomeIconEl.setAttribute('viewBox', biomeIconData.viewBox);
      biomeIconEl.innerHTML = biomeIconData.path;
      document.getElementById('biomeLabel').textContent = currentBiome.charAt(0).toUpperCase() + currentBiome.slice(1);

      // Update weather text
      document.getElementById('weatherName').textContent = weatherInfo.name;
      document.getElementById('weatherDetail').textContent = weatherInfo.detail;

      // Update time icon (SVG) and label (uppercase)
      document.getElementById('timeIcon').innerHTML = TIME_ICONS[currentTime] || TIME_ICONS.morning;
      document.getElementById('timeLabel').textContent = currentTime.toUpperCase();

      // Update temperature feel and wind speed
      document.getElementById('tempFeel').textContent = getTempFeel();
      document.getElementById('windSpeed').textContent = getWindSpeed();

      // Update particles (always reset for 'rays' since it changes based on time)
      if (particleSystem) {
        if (weatherInfo.particles === 'rays') {
          // Force restart to switch between sun rays and stars based on time
          particleSystem.setType('none');
          particleSystem.setType('rays');
        } else {
          particleSystem.setType(weatherInfo.particles);
        }
      }

      // Handle storm lightning
      if (stormInterval) {
        clearInterval(stormInterval);
        stormInterval = null;
      }
      if (currentWeather === 'storm' || currentWeather === 'ice_storm') {
        stormInterval = setInterval(() => {
          if (Math.random() < 0.3) triggerLightning();
        }, 2000);
      }

      // Update time button states
      document.querySelectorAll('.time-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.time === currentTime);
      });
    }

    // Populate weather dropdown based on biome
    function populateWeatherOptions() {
      const select = document.getElementById('weatherSelect');
      const options = BIOME_WEATHER[currentBiome] || ['clear'];

      select.innerHTML = '';
      options.forEach(weather => {
        const opt = document.createElement('option');
        opt.value = weather;
        opt.textContent = (WEATHER_INFO[weather]?.name || weather).charAt(0).toUpperCase() +
                         (WEATHER_INFO[weather]?.name || weather).slice(1);
        select.appendChild(opt);
      });

      // If current weather isn't valid for new biome, select first option
      if (!options.includes(currentWeather)) {
        currentWeather = options[0];
      }
      select.value = currentWeather;
    }

    // Setup event handlers
    function setupControls() {
      // Biome select
      document.getElementById('biomeSelect').addEventListener('change', (e) => {
        currentBiome = e.target.value;
        populateWeatherOptions();
        updateWidget();
      });

      // Weather select
      document.getElementById('weatherSelect').addEventListener('change', (e) => {
        currentWeather = e.target.value;
        updateWidget();
      });

      // Time buttons
      document.querySelectorAll('.time-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          currentTime = btn.dataset.time;
          updateWidget();
        });
      });

      // Randomize button
      document.getElementById('randomizeBtn').addEventListener('click', () => {
        const options = BIOME_WEATHER[currentBiome];
        currentWeather = options[Math.floor(Math.random() * options.length)];
        document.getElementById('weatherSelect').value = currentWeather;
        updateWidget();
      });

    }

    // ===== FULLSCREEN MODE =====
    let isFullscreen = false;
    let fullscreenWidget = null;
    let fullscreenParticleSystem = null;
    let uiIdleTimer = null;

    // Fidelity mode for fullscreen - 2x gives best balance of quality and performance
    let fidelityMode = '2x';
    let currentFullscreenWidth = 329; // Track widget dimensions for resize
    let currentFullscreenHeight = 155;

    function showFullscreenUI() {
      const container = document.getElementById('fullscreenContainer');
      container.classList.add('ui-visible');

      // Clear existing timer
      if (uiIdleTimer) clearTimeout(uiIdleTimer);

      // Hide after 1.5 seconds of idle (slightly longer than 1s feels better)
      uiIdleTimer = setTimeout(() => {
        container.classList.remove('ui-visible');
      }, 1500);
    }

    function hideFullscreenUI() {
      const container = document.getElementById('fullscreenContainer');
      container.classList.remove('ui-visible');
      if (uiIdleTimer) {
        clearTimeout(uiIdleTimer);
        uiIdleTimer = null;
      }
    }

    function calculateScale(baseWidth = 329, baseHeight = 155) {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      // Use Math.max to FILL/COVER the viewport (crops edges rather than letterboxing)
      return Math.max(vw / baseWidth, vh / baseHeight);
    }

    function enterFullscreen() {
      if (isFullscreen) return;

      const container = document.getElementById('fullscreenContainer');
      const originalWidget = document.getElementById('weatherWidget');

      // Get original widget's position for zoom animation
      const rect = originalWidget.getBoundingClientRect();
      originalWidgetRect = rect; // Store for zoom out animation
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      // Determine render scale based on fidelity mode
      let renderScale = 1; // How much larger to render the widget
      let particleScale = 1; // Scale for particle system
      let widgetWidth = 329;
      let widgetHeight = 155;

      if (fidelityMode === '2x') {
        // Render at 2x size, particles at 2x
        renderScale = 2;
        particleScale = 2;
        widgetWidth = 658;
        widgetHeight = 310;
      } else if (fidelityMode === 'native') {
        // Render at near-viewport size
        // Calculate the scale needed to fill viewport
        const fillScale = Math.max(vw / 329, vh / 155);
        // Use that scale to determine native render size (capped at reasonable maximum)
        renderScale = Math.min(fillScale, 8); // Cap at 8x to avoid insane sizes
        particleScale = renderScale;
        widgetWidth = Math.round(329 * renderScale);
        widgetHeight = Math.round(155 * renderScale);
      }

      // Clone the widget
      fullscreenWidget = originalWidget.cloneNode(true);
      fullscreenWidget.id = 'fullscreenWidget';

      // For higher fidelity modes, resize the widget element
      if (renderScale > 1) {
        fullscreenWidget.style.width = widgetWidth + 'px';
        fullscreenWidget.style.height = widgetHeight + 'px';
        // Scale internal particle container
        const fsParticlesContainer = fullscreenWidget.querySelector('.weather-particles');
        fsParticlesContainer.style.width = widgetWidth + 'px';
        fsParticlesContainer.style.height = widgetHeight + 'px';
      }

      // Clear any existing widget in container
      const existingWidget = container.querySelector('.widget');
      if (existingWidget) existingWidget.remove();

      container.appendChild(fullscreenWidget);

      // Create new particle system for fullscreen widget with appropriate scale
      const fsParticles = fullscreenWidget.querySelector('.weather-particles');
      fsParticles.innerHTML = ''; // Clear cloned static particles
      fullscreenParticleSystem = new WeatherParticles(fsParticles, particleScale);

      // Set same weather type
      const weatherInfo = WEATHER_INFO[currentWeather] || { particles: 'none' };
      fullscreenParticleSystem.setType(weatherInfo.particles);
      fullscreenParticleSystem.start();

      // Calculate final transform scale (how much to scale the rendered widget to fill viewport)
      const finalScale = calculateScale(widgetWidth, widgetHeight);

      // Store dimensions for resize handler
      currentFullscreenWidth = widgetWidth;
      currentFullscreenHeight = widgetHeight;

      // Calculate starting position (where the original widget is)
      // The widget in fullscreen container is centered, so we need to offset from center
      const startX = rect.left + rect.width / 2 - vw / 2;
      const startY = rect.top + rect.height / 2 - vh / 2;

      // Add biome class to container so fullscreen UI inherits correct accent color
      // Remove any existing biome class first
      container.className = container.className.replace(/biome-\w+/g, '').trim();
      container.classList.add(`biome-${currentBiome}`);

      // Start with widget at original position and scale 1
      container.classList.add('zooming');
      fullscreenWidget.style.transform = `translate(${startX}px, ${startY}px) scale(1)`;
      fullscreenWidget.style.borderRadius = '20px';

      // Populate the fullscreen UI overlay (weatherInfo already declared above)
      const biomeIconData = BIOME_ICONS[currentBiome] || BIOME_ICONS.forest;
      const fsUI = document.getElementById('fullscreenUI');

      // Reset the animations by removing and re-adding
      fsUI.style.animation = 'none';
      const hint = container.querySelector('.fullscreen-hint');
      if (hint) hint.style.animation = 'none';
      fsUI.offsetHeight; // Trigger reflow
      fsUI.style.animation = '';
      if (hint) hint.style.animation = '';

      document.getElementById('fsTimeIcon').innerHTML = TIME_ICONS[currentTime] || TIME_ICONS.morning;
      document.getElementById('fsTimeLabel').textContent = currentTime.toUpperCase();
      document.getElementById('fsBiomeIcon').setAttribute('viewBox', biomeIconData.viewBox);
      document.getElementById('fsBiomeIcon').innerHTML = biomeIconData.path;
      document.getElementById('fsBiomeLabel').textContent = currentBiome.charAt(0).toUpperCase() + currentBiome.slice(1);
      document.getElementById('fsWeatherName').textContent = weatherInfo.name;
      document.getElementById('fsWeatherDetail').textContent = weatherInfo.detail;
      document.getElementById('fsTempFeel').textContent = getTempFeel();
      document.getElementById('fsWindSpeed').textContent = getWindSpeed();

      // Show container
      container.classList.add('active');

      // Request fullscreen API
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      }

      // Trigger zoom animation after a frame
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          container.classList.remove('zooming');
          fullscreenWidget.style.transform = `translate(0, 0) scale(${finalScale})`;
          fullscreenWidget.style.borderRadius = '0';
        });
      });

      isFullscreen = true;

      // Start storm lightning if needed
      if (currentWeather === 'storm' || currentWeather === 'ice_storm') {
        fullscreenStormInterval = setInterval(() => {
          if (Math.random() < 0.3) {
            const fsLightning = fullscreenWidget.querySelector('.lightning-flash');
            if (fsLightning) {
              fsLightning.classList.add('active');
              setTimeout(() => fsLightning.classList.remove('active'), 150);
            }
          }
        }, 2000);
      }

      // Show UI initially, then it will auto-hide after idle
      showFullscreenUI();
    }

    let fullscreenStormInterval = null;

    // Store original widget position for zoom out animation
    let originalWidgetRect = null;

    function exitFullscreen() {
      if (!isFullscreen) return;

      // Hide UI and clear timer
      hideFullscreenUI();

      const container = document.getElementById('fullscreenContainer');
      const originalWidget = document.getElementById('weatherWidget');

      // Exit browser fullscreen first (if active)
      if (document.fullscreenElement || document.webkitFullscreenElement) {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      }

      // Clear storm interval
      if (fullscreenStormInterval) {
        clearInterval(fullscreenStormInterval);
        fullscreenStormInterval = null;
      }

      // Animate zoom out
      if (fullscreenWidget && originalWidgetRect) {
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const rect = originalWidget.getBoundingClientRect();
        const endX = rect.left + rect.width / 2 - vw / 2;
        const endY = rect.top + rect.height / 2 - vh / 2;

        // Animate back to original position
        fullscreenWidget.style.transform = `translate(${endX}px, ${endY}px) scale(1)`;
        fullscreenWidget.style.borderRadius = '20px';

        // Wait for animation to complete, then clean up
        setTimeout(() => {
          // Stop fullscreen particle system
          if (fullscreenParticleSystem) {
            fullscreenParticleSystem.stop();
            fullscreenParticleSystem = null;
          }

          // Remove cloned widget
          if (fullscreenWidget) {
            fullscreenWidget.remove();
            fullscreenWidget = null;
          }

          container.classList.remove('active');
        }, 600); // Match the transition duration
      } else {
        // Fallback: just remove immediately
        if (fullscreenParticleSystem) {
          fullscreenParticleSystem.stop();
          fullscreenParticleSystem = null;
        }
        if (fullscreenWidget) {
          fullscreenWidget.remove();
          fullscreenWidget = null;
        }
        container.classList.remove('active');
      }

      isFullscreen = false;
    }

    function handleResize() {
      if (!isFullscreen || !fullscreenWidget) return;
      const scale = calculateScale(currentFullscreenWidth, currentFullscreenHeight);
      fullscreenWidget.style.transform = `translate(0, 0) scale(${scale})`;
    }

    function setupFullscreen() {
      const widget = document.getElementById('weatherWidget');
      const container = document.getElementById('fullscreenContainer');

      // Click widget to enter fullscreen
      widget.addEventListener('click', (e) => {
        // Don't trigger on control panel interactions
        if (e.target.closest('.control-panel')) return;
        enterFullscreen();
      });

      // Click anywhere in fullscreen to exit
      container.addEventListener('click', () => {
        exitFullscreen();
      });

      // Show UI on mouse/touch movement
      container.addEventListener('mousemove', () => {
        if (isFullscreen) showFullscreenUI();
      });
      container.addEventListener('touchstart', () => {
        if (isFullscreen) showFullscreenUI();
      });

      // Handle Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isFullscreen) {
          exitFullscreen();
        }
      });

      // Handle fullscreen API exit (e.g., pressing Escape in native fullscreen)
      document.addEventListener('fullscreenchange', () => {
        if (!document.fullscreenElement && isFullscreen) {
          exitFullscreen();
        }
      });
      document.addEventListener('webkitfullscreenchange', () => {
        if (!document.webkitFullscreenElement && isFullscreen) {
          exitFullscreen();
        }
      });

      // Handle resize/orientation change
      window.addEventListener('resize', handleResize);
      window.addEventListener('orientationchange', () => {
        // Small delay to let orientation finish
        setTimeout(handleResize, 100);
      });
    }

    // Initialize
    function init() {
      const widget = document.getElementById('weatherWidget');
      particleSystem = new WeatherParticles(document.getElementById('particles'));

      setupControls();
      setupFullscreen();
      populateWeatherOptions();

      // Start loaded state
      widget.classList.remove('loading');
      widget.classList.add('loaded');

      particleSystem.start();
      updateWidget();
    }

    init();
  </script>
</body>
</html>
